var currentIndex = 0;var mediaElements = document.querySelectorAll('.media'); // Selects all media typesvar backgrounds = ['','','','','','','','','','','','','',''];function showMedia(index) {    mediaElements.forEach(el => {        el.style.display = 'none';        var vid = el.querySelector('video');        if (vid) { vid.pause(); vid.currentTime = 0; }    });    var active = mediaElements[index];    active.style.display = 'block';    document.body.style.backgroundImage = `url('${backgrounds[index]}')`;    var vid2 = active.querySelector('video');    if (vid2) vid2.play();}function changeMedia(dir) {    clearTelestration(); clearSvgImages();    currentIndex = (currentIndex + dir + mediaElements.length) % mediaElements.length;    showMedia(currentIndex);}var currentSvg = null;var svgDetails = {svg1: { path: 'media/SVG/outage.svg', width: '50px', height: '50px' },svg2: { path: 'media/SVG/tornado.svg', width: '50px', height: '50px' },svg3: { path: 'media/SVG/thunderstorm.svg', width: '50px', height: '50px' }};var placingSvg = false;var allowPlacement = false;function startPlacingSvg(svgKey) {    currentSvg = svgDetails[svgKey];    placingSvg = true;    allowPlacement = false; // Initially do not allow placement until the next click.}function stopPlacingSvg() {    placingSvg = false;    currentSvg = null;}function clearSvgImages() {    document.querySelectorAll('img.placed-svg').forEach(svg => svg.remove());}document.addEventListener('click', function (event) {    const target = event.target;    // Ignore clicks on any buttons    if (target.closest('button')) return;    if (placingSvg && currentSvg) {        const x = event.pageX - (parseInt(currentSvg.width) / 2);        const y = event.pageY - (parseInt(currentSvg.height) / 2);        const svgImage = document.createElement('img');        svgImage.src = currentSvg.path;        svgImage.className = 'placed-svg';        svgImage.style.position = 'fixed';        svgImage.style.left = `${x}px`;        svgImage.style.top = `${y}px`;        svgImage.style.width = currentSvg.width;        svgImage.style.height = currentSvg.height;        svgImage.style.pointerEvents = 'none';        // Try video wrapper first        const wrapper = document.querySelector('.video-container[style*="display: block"] .video-wrapper');        if (wrapper) {            const rect = wrapper.getBoundingClientRect();            svgImage.style.left = `${event.pageX - rect.left - parseInt(currentSvg.width) / 2}px`;            svgImage.style.top = `${event.pageY - rect.top - parseInt(currentSvg.height) / 2}px`;            wrapper.appendChild(svgImage);        } else {            // No video wrapper, append directly to body (over background image)            document.body.appendChild(svgImage);        }    }});showMedia(currentIndex);// Telestration Logicconst canvasEl = document.getElementById('telestration-canvas');const ctx = canvasEl.getContext('2d');const penToolBtnEl = document.getElementById('pen-tool');const cursorToolBtnEl = document.getElementById('cursor-tool');const colorBtnsEl = document.querySelectorAll('.telestration-color-btn');const weightBtnsEl = document.querySelectorAll('.telestration-weight-btn');const shapeBtnsEl = document.querySelectorAll('.telestration-shape-btn');const clearCanvasBtnEl = document.getElementById('clear-canvas-btn');let currentTool = 'pen', strokeColor = '#FF0000', lineWidth = 2;let shapeStartX, shapeStartY, isPenDrawing = false, penLastX, penLastY, penInitialX, penInitialY;function resizeCanvas() {    canvasEl.width = window.innerWidth;    canvasEl.height = window.innerHeight;}resizeCanvas();window.addEventListener('resize', resizeCanvas);function updateActiveBtn(selector, clicked) {    document.querySelectorAll(selector).forEach(btn => btn.classList.remove('active'));    if (clicked) clicked.classList.add('active');}penToolBtnEl.addEventListener('click', () => {    currentTool = 'pen';    updateActiveBtn('.telestration-tool-btn', penToolBtnEl);    updateActiveBtn('.telestration-shape-btn', null);    canvasEl.classList.add('active-drawing');});cursorToolBtnEl.addEventListener('click', () => {    currentTool = 'cursor';    updateActiveBtn('.telestration-tool-btn', cursorToolBtnEl);    updateActiveBtn('.telestration-shape-btn', null);    canvasEl.classList.remove('active-drawing');});colorBtnsEl.forEach(btn => btn.addEventListener('click', () => {    strokeColor = btn.dataset.color;    updateActiveBtn('.telestration-color-btn', btn);}));weightBtnsEl.forEach(btn => btn.addEventListener('click', () => {    lineWidth = parseInt(btn.dataset.weight, 10);    updateActiveBtn('.telestration-weight-btn', btn);}));shapeBtnsEl.forEach(btn => btn.addEventListener('click', () => {    currentTool = btn.dataset.shape;    updateActiveBtn('.telestration-shape-btn', btn);    updateActiveBtn('.telestration-tool-btn', null);    canvasEl.classList.add('active-drawing');}));clearCanvasBtnEl.addEventListener('click', () => {    ctx.clearRect(0, 0, canvasEl.width, canvasEl.height);});function clearTelestration() {    ctx.clearRect(0, 0, canvasEl.width, canvasEl.height);}canvasEl.addEventListener('mousedown', e => {    if (!canvasEl.classList.contains('active-drawing')) return;    const rect = canvasEl.getBoundingClientRect();    const x = e.clientX - rect.left;    const y = e.clientY - rect.top;    if (currentTool === 'pen') {        isPenDrawing = true;        penInitialX = penLastX = x;        penInitialY = penLastY = y;        ctx.beginPath(); ctx.moveTo(penLastX, penLastY);    } else {        shapeStartX = x; shapeStartY = y;    }});canvasEl.addEventListener('mousemove', e => {    if (!canvasEl.classList.contains('active-drawing')) return;    const rect = canvasEl.getBoundingClientRect();    const x = e.clientX - rect.left;    const y = e.clientY - rect.top;    if (currentTool === 'pen' && isPenDrawing) {        const midX = (penLastX + x) / 2;        const midY = (penLastY + y) / 2;        ctx.quadraticCurveTo(penLastX, penLastY, midX, midY);        ctx.strokeStyle = strokeColor;        ctx.lineWidth = lineWidth;        ctx.lineCap = 'round';        ctx.lineJoin = 'round';        ctx.stroke();        penLastX = x; penLastY = y;        ctx.beginPath(); ctx.moveTo(midX, midY);    }});canvasEl.addEventListener('mouseup', e => {    if (!canvasEl.classList.contains('active-drawing')) return;    const rect = canvasEl.getBoundingClientRect();    const x = e.clientX - rect.left;    const y = e.clientY - rect.top;    ctx.strokeStyle = strokeColor;    ctx.lineWidth = lineWidth;    ctx.lineCap = 'round';    ctx.lineJoin = 'round';    if (currentTool === 'pen') {        if (!isPenDrawing) return;        isPenDrawing = false;        if (penInitialX === x && penInitialY === y) {            ctx.fillStyle = strokeColor;            ctx.beginPath();            ctx.arc(penInitialX, penInitialY, lineWidth/2, 0, 2*Math.PI);            ctx.fill();        } else {            ctx.lineTo(x, y); ctx.stroke();        }    } else if (currentTool === 'line') {        ctx.beginPath(); ctx.moveTo(shapeStartX, shapeStartY);        ctx.lineTo(x, y); ctx.stroke();    } else if (currentTool === 'arrow') {        drawArrow(shapeStartX, shapeStartY, x, y);    } else if (currentTool === 'rectangle') {        ctx.beginPath(); ctx.rect(shapeStartX, shapeStartY, x-shapeStartX, y-shapeStartY); ctx.stroke();    } else if (currentTool === 'circle') {        const rectX = Math.min(shapeStartX, x);        const rectY = Math.min(shapeStartY, y);        const width = Math.abs(x - shapeStartX);        const height = Math.abs(y - shapeStartY);        const centerX = rectX + width / 2;        const centerY = rectY + height / 2;        const radius = Math.min(width, height) / 2;        ctx.beginPath();        ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);        ctx.stroke();    }});canvasEl.addEventListener('mouseleave', () => {    if (isPenDrawing) isPenDrawing = false;});// Touch support for telestrationcanvasEl.addEventListener('touchstart', e => {    if (!canvasEl.classList.contains('active-drawing')) return;    const touch = e.touches[0];    const rect = canvasEl.getBoundingClientRect();    const x = touch.clientX - rect.left;    const y = touch.clientY - rect.top;    if (currentTool === 'pen') {        isPenDrawing = true;        penInitialX = penLastX = x;        penInitialY = penLastY = y;        ctx.beginPath(); ctx.moveTo(penLastX, penLastY);    } else {        shapeStartX = x; shapeStartY = y;    }});canvasEl.addEventListener('touchmove', e => {    if (!canvasEl.classList.contains('active-drawing')) return;    e.preventDefault(); // Prevent scrolling while drawing    const touch = e.touches[0];    const rect = canvasEl.getBoundingClientRect();    const x = touch.clientX - rect.left;    const y = touch.clientY - rect.top;    if (currentTool === 'pen' && isPenDrawing) {        const midX = (penLastX + x) / 2;        const midY = (penLastY + y) / 2;        ctx.quadraticCurveTo(penLastX, penLastY, midX, midY);        ctx.strokeStyle = strokeColor;        ctx.lineWidth = lineWidth;        ctx.lineCap = 'round';        ctx.lineJoin = 'round';        ctx.stroke();        penLastX = x; penLastY = y;        ctx.beginPath(); ctx.moveTo(midX, midY);    }}, { passive: false });canvasEl.addEventListener('touchend', e => {    if (!canvasEl.classList.contains('active-drawing')) return;    const touch = e.changedTouches[0];    const rect = canvasEl.getBoundingClientRect();    const x = touch.clientX - rect.left;    const y = touch.clientY - rect.top;    ctx.strokeStyle = strokeColor;    ctx.lineWidth = lineWidth;    ctx.lineCap = 'round';    ctx.lineJoin = 'round';    if (currentTool === 'pen') {        if (!isPenDrawing) return;        isPenDrawing = false;        if (penInitialX === x && penInitialY === y) {            ctx.fillStyle = strokeColor;            ctx.beginPath();            ctx.arc(penInitialX, penInitialY, lineWidth/2, 0, 2*Math.PI);            ctx.fill();        } else {            ctx.lineTo(x, y); ctx.stroke();        }    } else if (currentTool === 'line') {        ctx.beginPath(); ctx.moveTo(shapeStartX, shapeStartY);        ctx.lineTo(x, y); ctx.stroke();    } else if (currentTool === 'arrow') {        drawArrow(shapeStartX, shapeStartY, x, y);    } else if (currentTool === 'rectangle') {        ctx.beginPath(); ctx.rect(shapeStartX, shapeStartY, x-shapeStartX, y-shapeStartY); ctx.stroke();    } else if (currentTool === 'circle') {        const rectX = Math.min(shapeStartX, x);        const rectY = Math.min(shapeStartY, y);        const width = Math.abs(x - shapeStartX);        const height = Math.abs(y - shapeStartY);        const centerX = rectX + width / 2;        const centerY = rectY + height / 2;        const radius = Math.min(width, height) / 2;        ctx.beginPath();        ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);        ctx.stroke();    }});function drawArrow(fromX, fromY, toX, toY) {    const headlen = 10 + lineWidth*2;    const dx = toX - fromX, dy = toY - fromY;    const angle = Math.atan2(dy, dx);    ctx.beginPath();    ctx.moveTo(fromX, fromY);    ctx.lineTo(toX, toY);    ctx.lineTo(toX - headlen*Math.cos(angle - Math.PI/6), toY - headlen*Math.sin(angle - Math.PI/6));    ctx.moveTo(toX, toY);    ctx.lineTo(toX - headlen*Math.cos(angle + Math.PI/6), toY - headlen*Math.sin(angle + Math.PI/6));    ctx.stroke();}// Activate pen tool by defaultpenToolBtnEl.click();const svgButtons = [    document.getElementById('startSvg1'),    document.getElementById('startSvg2'),    document.getElementById('stopSvg')];function deactivateAllTools() {    // Deactivate telestration tools    document.querySelectorAll('.telestration-tool-btn, .telestration-shape-btn').forEach(btn => {        btn.classList.remove('active');    });    canvasEl.classList.remove('active-drawing');    // Deactivate SVG placement    placingSvg = false;    currentSvg = null;    allowPlacement = false;    // Deactivate SVG buttons    svgButtons.forEach(btn => btn.classList.remove('active'));}// Override existing handlerspenToolBtnEl.addEventListener('click', () => {    deactivateAllTools();    currentTool = 'pen';    penToolBtnEl.classList.add('active');    canvasEl.classList.add('active-drawing');});cursorToolBtnEl.addEventListener('click', () => {    deactivateAllTools();    currentTool = 'cursor';    cursorToolBtnEl.classList.add('active');});shapeBtnsEl.forEach(btn => btn.addEventListener('click', () => {    deactivateAllTools();    currentTool = btn.dataset.shape;    btn.classList.add('active');    canvasEl.classList.add('active-drawing');}));// SVG button overridesfunction activateSvgButton(btn, svgKey) {    deactivateAllTools();    btn.classList.add('active');    currentSvg = svgDetails[svgKey];    placingSvg = true;}svgButtons[0].addEventListener('click', () => activateSvgButton(svgButtons[0], 'svg1'));svgButtons[1].addEventListener('click', () => activateSvgButton(svgButtons[1], 'svg2'));svgButtons[2].addEventListener('click', () => activateSvgButton(svgButtons[2], 'svg3'));